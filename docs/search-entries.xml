<znai>
  <entry>
    <url>/docs</url>
    <fullTitle>Liftwizard Liftwizard</fullTitle>
    <text>
      <text>Liftwizard is a collection of bundles and add-ons for https://www.dropwizard.io/ Dropwizard, the Java framework for writing web services.There are very few dependencies between the bundles, so you can pick and choose the ones you want. Module groups The bundles can be loosely grouped into categories.Dropwizard configuration JSON serialization/deserialization Servlet client/server logging GraphQL utility https://github.com/goldmansachs/reladomo Reladomo ORM integration for Dropwizard Other Dropwizard utility Guide structure In this guide, we'll start with the application https://github.com/dropwizard/dropwizard/tree/master/dropwizard-example dropwizard-example which is a maven module that's part of the main Dropwizard repository. We'll gradually turn it into https://github.com/motlin/liftwizard/tree/master/liftwizard-example liftwizard-example , an application with an identical service api that uses as many Liftwizard features as possible.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/introduction/liftwizard</url>
    <fullTitle>Liftwizard: Liftwizard,  [Introduction]</fullTitle>
    <text>
      <text>Liftwizard is a collection of bundles and add-ons for https://www.dropwizard.io/ Dropwizard, the Java framework for writing web services.There are very few dependencies between the bundles, so you can pick and choose the ones you want.The bundles can be loosely grouped into categories:Dropwizard configuration and bundles Jackson JSON serialization/deserialization Servlet client/server logging https://github.com/goldmansachs/reladomo Reladomo ORM integration for Dropwizard JUnit 4 and JUnit 5 test utilities</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/environment-variable-substitution#in-example-applications</url>
    <fullTitle>Liftwizard: Environment Variable Substitution, in example applications [Configuration]</fullTitle>
    <text>
      <text>The EnvironmentConfigBundle supports environment variable substitution inside Dropwizard configuration files.In the example applications, environment variable substitution is used for defaultName . yaml template: Hello, %s! defaultName: ${DW_DEFAULT_NAME:-Stranger} We can see this in action by running the render command, with and without the environment variable set. bash $ java -jar target/liftwizard-example-0.1.0.jar render example.yml --include-default INFO [2020-05-02 03:07:41,910] com.example.helloworld.cli.RenderCommand: DEFAULT => Hello, Stranger! $ DW_DEFAULT_NAME=EnvSubstitution java -jar target/liftwizard-example-0.1.0.jar render example.yml --include-default INFO [2020-05-02 03:08:05,685] com.example.helloworld.cli.RenderCommand: DEFAULT => Hello, EnvSubstitution!</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/environment-variable-substitution#in-dropwizard-example</url>
    <fullTitle>Liftwizard: Environment Variable Substitution, in dropwizard-example [Configuration]</fullTitle>
    <text>
      <text>java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { // Enable variable substitution with environment variables bootstrap.setConfigurationSourceProvider( new SubstitutingSourceProvider( bootstrap.getConfigurationSourceProvider(), new EnvironmentVariableSubstitutor(false) ) ); // ... }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/environment-variable-substitution#in-liftwizard-example</url>
    <fullTitle>Liftwizard: Environment Variable Substitution, in liftwizard-example [Configuration]</fullTitle>
    <text>
      <text>java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.addBundle(new EnvironmentConfigBundle()); // ... } EnvironmentConfigBundle lives in the liftwizard-bundle-environment-config module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-environment-config&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/json5-configuration#configuration-through-json5-instead-of-yaml</url>
    <fullTitle>Liftwizard: Json5 Configuration, Configuration through json5 instead of yaml [Configuration]</fullTitle>
    <text>
      <text>Dropwizard's configuration is specified in yaml by default. While yaml has nice properties, you may prefer json or some other format.Dropwizard's https://www.dropwizard.io/en/latest/manual/core.html#configuration documentation claims:If your configuration file doesn't end in .yml or .yaml, Dropwizard tries to parse it as a JSON file.This is easily disproved by renaming example.yml to example.json and trying to run the application. It will incorrectly start without error.Since json syntax is a subset of yml syntax, you can go ahead and convert your configuration file to json without changing the file extension from yaml or yml. However, this approach doesn't prevent you from accidentally using yaml syntax.You can change your application to use json for its configuration using JsonConfigurationFactoryFactory . java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.setConfigurationFactoryFactory(new JsonConfigurationFactoryFactory&lt;&gt;()); // ... } JsonConfigurationFactoryFactory uses json5 syntax by default, using optional features in Jackson. So you'll still be able to include comments inside your configuration files.After adding the bundle, you'll have to convert your configuration files to json5 and rename them. So example.yml becomes example.json5 . Configuration files used in DropwizardAppRule / DropwizardAppExtension tests must be converted as well. So src/test/resources/test-example.yml becomes src/test/resources/test-example.json5</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/json5-configuration#adding-the-dependency</url>
    <fullTitle>Liftwizard: Json5 Configuration, Adding the dependency [Configuration]</fullTitle>
    <text>
      <text>JsonConfigurationFactoryFactory lives in the liftwizard-configuration-factory-json module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-configuration-factory-json&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/configuration/ConfigLoggingBundle#adding-the-dependency</url>
    <fullTitle>Liftwizard: ConfigLoggingBundle, Adding the dependency [Configuration]</fullTitle>
    <text>
      <text>The ConfigLoggingBundle logs the Dropwizard configuration using SLF4J. It serializes the in-memory configuration object to json and logs that json, not the contents of the original configuration file. The output contains default values set by constructors, that were not specified in the original configuration file.To turn it on, add ConfigLoggingBundle to the list of registered bundles. @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.setConfigurationFactoryFactory(new JsonConfigurationFactoryFactory&lt;&gt;()); bootstrap.addBundle(new EnvironmentConfigBundle()); bootstrap.addBundle(new ObjectMapperBundle()); bootstrap.addBundle(new ConfigLoggingBundle()); StructuredArgumentsMDCLogger structuredLogger = new StructuredArgumentsMDCLogger(bootstrap.getObjectMapper()); bootstrap.addBundle(new JerseyHttpLoggingBundle(structuredLogger)); bootstrap.addBundle(new ClockBundle()); bootstrap.addBundle(new UUIDBundle()); bootstrap.addBundle(new H2Bundle()); bootstrap.addBundle(new ConnectionManagerHolderBundle()); bootstrap.addBundle(new ReladomoBundle()); bootstrap.addCommand(new RenderCommand()); bootstrap.addBundle(new AssetsBundle()); bootstrap.addBundle(new MigrationsBundle&lt;&gt;() { @Override public DataSourceFactory getDataSourceFactory(HelloWorldConfiguration configuration) { return configuration.getNamedDataSourcesFactory().getNamedDataSourceFactoryByName("h2-tcp"); } }); bootstrap.addBundle(new LiftwizardLiquibaseMigrationBundle()); bootstrap.addBundle(new ViewBundle&lt;&gt;() { @Override public Map&lt;String, Map&lt;String, String>> getViewConfiguration(HelloWorldConfiguration configuration) { return configuration.getViewRendererConfiguration(); } }); bootstrap.addBundle(new Slf4jUncaughtExceptionHandlerBundle()); } Now HelloWorldApplication will log something like this on startup: INFO 12:53:29 [main] {liftwizard.priority=-8, liftwizard.bundle=ConfigLoggingBundle} io.liftwizard.dropwizard.bundle.config.logging.ConfigLoggingBundle: Inferred Dropwizard configuration: json5 { "template": "Hello, %s!", "defaultName": "Stranger", "configLogging": { "enabled": true }, // ... "metrics": { "frequency": "1 minute", "reporters": [ ] } } Note that the metrics section at the end was not specified in test-example.json5 . It comes from serializing the output of io.dropwizard.Configuration.getMetricsFactory() . @JsonProperty("metrics") public MetricsFactory getMetricsFactory() { return metrics; } This output can be helpful for fleshing out the configuration file with default options. Including "redundant" defaults makes it easier to edit the configuration by hand. It's easier to flip a boolean flag from false to true than to first figure out where in the configuration file it belongs and the exact spelling of its key.The ConfigLoggingBundle also logs the "default" configuration at the DEBUG level. It does this by instantiating a new copy of the configuration class using the default no-arg constructor, serializing it to json, and logging it. The default configuration output can be useful for finding redundant configuration to remove. ConfigLoggingBundle lives in the liftwizard-bundle-logging-config module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-logging-config&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/jackson/ObjectMapperBundle#adding-the-dependency</url>
    <fullTitle>Liftwizard: ObjectMapperBundle, Adding the dependency [Jackson]</fullTitle>
    <text>
      <text>The ObjectMapperBundle configures the Jackson ObjectMapper used by Dropwizard for serializing and deserializing all responses, as well as for logging by bundles such as liftwizard-bundle-logging-config . ObjectMapperBundle supports configuring pretty-printing on or off, and serialization inclusion to any value in Jackson's JsonInclude.Include . ObjectMapperBundle also turns on all json5 features, turns on FAIL_ON_UNKNOWN_PROPERTIES , turns on STRICT_DUPLICATE_DETECTION , and turns on serialization of dates and Strings.To turn it on, add ObjectMapperBundle to the list of registered bundles. java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { // JsonConfigurationFactoryFactory uses a separate ObjectMapper, and can be configured earlier bootstrap.setConfigurationFactoryFactory(new JsonConfigurationFactoryFactory&lt;&gt;()); bootstrap.addBundle(new EnvironmentConfigBundle()); bootstrap.addBundle(new ObjectMapperBundle()); // ConfigLoggingBundle uses the ObjectMapper configured by ObjectMapperBundle bootstrap.addBundle(new ConfigLoggingBundle()); // ... } You'll be able to see that ObjectMapperBundle is working because the output of ConfigLoggingBundle will now be pretty-printed by default. ObjectMapperBundle lives in the liftwizard-bundle-object-mapper module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-object-mapper&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/JerseyHttpLoggingBundle</url>
    <fullTitle>Liftwizard: JerseyHttpLoggingBundle,  [Logging]</fullTitle>
    <text>
      <text>The JerseyHttpLoggingBundle is an alternative to Jersey's LoggingFeature . Jersey's LoggingFeature can be configured to log or not log bodies, but it cannot be configured to exclude headers. Since headers can include authentication tokens, you may not want to log headers, or only log those in an allow-list.The bundle can be configured:include/exclude request bodies include/exclude response bodies allow-list of headers include/exclude the list of excluded header names the max body size before truncation Through code, the bundle can be configured to log using different combinations of slf4j/log4j/logback with context in MDC or OpenTracing or a Map.To turn it on, add JerseyHttpLoggingBundle to the list of registered bundles. java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.setConfigurationFactoryFactory(new JsonConfigurationFactoryFactory&lt;&gt;()); bootstrap.addBundle(new EnvironmentConfigBundle()); bootstrap.addBundle(new ObjectMapperBundle()); bootstrap.addBundle(new ConfigLoggingBundle()); StructuredArgumentsMDCLogger structuredLogger = new StructuredArgumentsMDCLogger(bootstrap.getObjectMapper()); bootstrap.addBundle(new JerseyHttpLoggingBundle(structuredLogger)); // ... } The bundle registers filters which gather all the arguments to log. A "logger" is passed into the constructor which abstracts over whether the logging uses logback or log4j, whether the structured arguments are converted into MDC, Markers, or a Map. The StructuredArgumentsMDCLogger in the example above logs using slf4j with context in MDC. java var mdcLogger = new StructuredArgumentsMDCLogger(bootstrap.getObjectMapper()); var logstashLogger = new StructuredArgumentsLogstashEncoderLogger(); Consumer&lt;StructuredArguments> structuredLogger = structuredArguments -> { mdcLogger.accept(structuredArguments); logstashLogger.accept(structuredArguments); }; bootstrap.addBundle(new JerseyHttpLoggingBundle(structuredLogger)); JerseyHttpLoggingBundle lives in the liftwizard-bundle-logging-http module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-logging-http&lt;/artifactId> &lt;/dependency> In order to see the logging in action, we'll need to configure a log format that includes mdc and markers. test-example.json5 src/test/resources/test-example.json5 json5 { "type": "console", "timeZone": "${LOGGING_TIMEZONE:-system}", "logFormat": "%highlight(%-5level) %cyan(%date{HH:mm:ss.SSS, %dwTimeZone}) %gray(\\(%file:%line\\)) [%white(%thread)] %blue(%marker) {%magenta(%mdc)} %green(%logger): %message%n%rootException", "includeCallerData": true, } Next, lets turn on all the basic filters and see how they change what gets logged. Logging output We can rerun IntegrationTest and see the new logs in action. console DEBUG 13:21:49 [dw-249] io.liftwizard.servlet.logging.mdc.StructuredArgumentsMDCLogger: Response sent &lt;&gt; &lt; response.http.elapsedNanos=1000000000, request.http.method=GET, request.http.parameters.query.name=Dr. IntegrationTest, request.http.path.full=/hello-world, request.http.path.absolute=http://localhost:63842/hello-world, request.http.client.port=63855, request.http.headers.User-Agent=Jersey/2.25.1 (HttpUrlConnection 17.0.2), request.http.server.port=63842, request.http.client.host=127.0.0.1, request.resourceClass=com.example.helloworld.resources.HelloWorldResource, request.http.path.template=/hello-world, request.http.server.name=localhost, request.http.headers.Host=localhost:63842, response.http.headers.Content-Type=application/json, response.http.contentType=application/json, response.http.entityType=com.example.helloworld.api.Saying, response.http.status.code=200, request.http.client.address=127.0.0.1, request.resourceMethod=sayHello, response.http.status.phrase=OK, response.http.body={ "id" : 1, "content" : "Hello, Dr. IntegrationTest!" }, response.http.contentLength=59, request.http.server.scheme=http, response.http.status.status=OK, response.http.status.family=SUCCESSFUL> Logstash encoder liftwizard-config-logging-logstash-file is a Dropwizard AppenderFactory . It sets up a file appender that logs one json object per log statement. The json is formatted by https://github.com/logstash/logstash-logback-encoder logstash-logback-encoder and is ready to be parsed by logstash.Let's add the logstash-file appender to the list of configured appenders. test-example.json5 src/test/resources/test-example.json5 json5 { // ... "logging": { "level": "DEBUG", "appenders": [ { "type": "console", "timeZone": "${LOGGING_TIMEZONE:-system}", "logFormat": "%highlight(%-5level) %cyan(%date{HH:mm:ss.SSS, %dwTimeZone}) %gray(\\(%file:%line\\)) [%white(%thread)] %blue(%marker) {%magenta(%mdc)} %green(%logger): %message%n%rootException", "includeCallerData": true, }, { "type" : "file-logstash", "currentLogFilename" : "./logs/logstash.jsonl", "archivedLogFilenamePattern": "./logs/logstash-%d.jsonl", "includeCallerData" : true, "encoder": { "includeContext": true, "includeMdc": true, "includeStructuredArguments": true, "includedNonStructuredArguments": true, "includeTags": true, "prettyPrint": false, } } ] }, // ... } logstash.jsonl logs/logstash.jsonl snippet</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/buffered-logging</url>
    <fullTitle>Liftwizard: Buffered Logging,  [Logging]</fullTitle>
    <text>
      <text>In unit tests, it can be useful to suppress all logging for successful tests, but still log everything when tests fail.In order to accomplish this, we need to buffer all logging before we know the result of the test, and then flush or clear the buffer once we know the outcome. BufferedAppender BufferedAppender is the logback appender that buffers all logging until it receives a CLEAR or FLUSH marker.You can use directly in logback configuration. It requires a delegate appender for flushing, declared using an appender-ref . BufferedAppender lives in the liftwizard-logging-buffered-appender module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-logging-buffered-appender&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> Log Markers We must log CLEAR and FLUSH markers to instruct BufferedAppender to clear or flush its logs. If you are using JUnit 4 or 5, you can use the included Rule or Extension to log these markers automatically. JUnit 4 LogMarkerTestRule is a JUnit 4 Rule that clears the buffer before all tests and flushes the buffer after failed tests. It does this by logging CLEAR and FLUSH markers. java public class ExampleTest { @Rule public final TestRule logMarkerTestRule = new LogMarkerTestRule(); @Test public void smokeTest() { // test code } } LogMarkerTestRule lives in the liftwizard-junit-rule-log-marker module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-junit-rule-log-marker&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> JUnit 5 LogMarkerTestExtension is a JUnit 5 Extension that clears the buffer before all tests and flushes the buffer after failed tests. It does this by logging CLEAR and FLUSH markers. java @ExtendWith(LogMarkerTestExtension.class) public class ExampleTest { @Test public void smokeTest() { // test code } } LogMarkerTestExtension lives in the liftwizard-junit-extension-log-marker module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-junit-extension-log-marker&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> BufferedAppenderFactory The BufferedAppenderFactory allows you to use an appender with the type buffered where you would otherwise use console in your Dropwizard configuration. json5 "logging": { "level": "DEBUG", "appenders": [ { "type": "buffered", "timeZone": "${LOGGING_TIMEZONE:-system}", "logFormat": "%highlight(%-5level) %cyan(%date{HH:mm:ss.SSS, %dwTimeZone}) %gray(\\(%file:%line\\)) [%white(%thread)] %blue(%marker) {%magenta(%mdc)} %green(%logger): %message%n%rootException", "includeCallerData": true, }, ] } BufferedAppenderFactory lives in the liftwizard-config-logging-buffered module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-config-logging-buffered&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> Note: BufferedAppenderFactory is primarily useful for tests that use https://www.dropwizard.io/en/release-2.1.x/manual/testing.html#junit-4 Dropwizard's JUnit 4 Rule DropwizardAppRule or https://www.dropwizard.io/en/release-2.1.x/manual/testing.html#junit-5 Dropwizard's JUnit 5 Extension DropwizardAppExtension . java private final TestRule logMarkerTestRule = new LogMarkerTestRule(); private final DropwizardAppRule&lt;HelloWorldConfiguration> dropwizardAppRule = new DropwizardAppRule&lt;&gt;( HelloWorldApplication.class, ResourceHelpers.resourceFilePath("test-example.json5")); @Rule public final RuleChain ruleChain = RuleChain .outerRule(this.dropwizardAppRule) .around(this.logMarkerTestRule); Note: LogMarkerTestRule needs to be an inner rule, with any other rules that tear down logging outer to it.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/filter-factories</url>
    <fullTitle>Liftwizard: Filter Factories,  [Logging]</fullTitle>
    <text>
      <text>Dropwizard comes with support for dynamic configuration of https://www.dropwizard.io/en/latest/manual/core.html#logging-filters log filters. However, it ships with just a single filter, the https://www.dropwizard.io/en/latest/manual/core.html#filtering-request-logs-for-a-specific-uri UriFilterFactory.One can create logging filters that will intercept log statements before they are written and decide if they’re allowed. Log filters can work on both regular statements and request log statements.Liftwizard provides an improved RequestUrlFilterFactory for request logs and JaninoFilterFactory for plain logs. RequestUrlFilterFactory RequestUrlFilterFactory is an improved version of UriFilterFactory . It can filter access logs that do or don't match a list of urls.To use it, add a dependency on liftwizard-config-logging-filter-requesturl . Then add a filter factory to your config with type url and a list of urls to include or exclude. The default value of onMatch is ch.qos.logback.core.spi.FilterReply.DENY . JaninoFilterFactory JaninoFilterFactory allows you to specify the filter condition in a snippet of Java code that gets compiled with https://janino-compiler.github.io/janino/ Janino.To use it, add a dependency on liftwizard-config-logging-filter-janino . Then add a filter factory to your config with type janino and a javaExpression that evaluates to a boolean. The default value of onMatch is ch.qos.logback.core.spi.FilterReply.DENY . json5 { "logging": { "level": "DEBUG", "appenders": [ { "type": "console", "timeZone": "${LOGGING_TIMEZONE:-system}", "logFormat": "%highlight(%-5level) %cyan(%date{HH:mm:ss.SSS, %dwTimeZone}) %gray(\\(%file:%line\\)) [%white(%thread)] %blue(%marker) {%magenta(%mdc)} %green(%logger): %message%n%rootException", "filterFactories": [ { "type": "janino", "javaExpression": "logger.equals(\"io.liftwizard.logging.p6spy.P6SpySlf4jLogger\") &amp;&amp; mdc.get(\"liftwizard.bundle\").equals(\"DdlExecutorBundle\")", "onMatch": "DENY" } ] } ] } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/Slf4jUncaughtExceptionHandlerBundle#the-logs</url>
    <fullTitle>Liftwizard: Slf4jUncaughtExceptionHandlerBundle, The logs [Logging]</fullTitle>
    <text>
      <text>Slf4jUncaughtExceptionHandler is an https://docs.oracle.com/en%2Fjava%2Fjavase%2F21%2Fdocs%2Fapi%2F%2F/java.base/java/lang/Thread.UncaughtExceptionHandler.html UncaughtExceptionHandler that logs uncaught exceptions using SLF4J. Slf4jUncaughtExceptionHandlerBundle is a Dropwizard bundle that installs Slf4jUncaughtExceptionHandler on startup.When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException method, passing the thread and the exception as arguments.When an uncaught exception is thrown, Slf4jUncaughtExceptionHandler logs the exception at the WARN level.With logback configuration like this: xml &lt;appender name="Console" class="ch.qos.logback.core.ConsoleAppender"> &lt;encoder> &lt;pattern>%highlight(%-5level) %cyan(%date{HH:mm:ss.SSS, ${LOGGING_TIMEZONE}}) %gray(\(%file:%line\)) [%white(%thread)] %blue(%marker) {%magenta(%mdc)} %green(%logger): %message%n%rootException&lt;/pattern> &lt;/encoder> &lt;/appender> The logs look like this: shell WARN 12:00:00.000 (Slf4jUncaughtExceptionHandler.java:46) [main] {exceptionClass=io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest.RootException, liftwizard.error.message=example root, liftwizard.error.kind=io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest.RootException, threadName=main, exceptionMessage=example root, liftwizard.error.thread=main} io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandler: Exception in thread "main" io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest$CauseException: example cause at io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest.testUncaughtException(Slf4jUncaughtExceptionHandlerTest.java:26) ~[test-classes/:na] ... 68 common frames omitted Wrapped by: io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest$RootException: example root at io.liftwizard.logging.slf4j.uncaught.exception.handler.Slf4jUncaughtExceptionHandlerTest.testUncaughtException(Slf4jUncaughtExceptionHandlerTest.java:27) ~[test-classes/:na]</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/Slf4jUncaughtExceptionHandlerBundle#with-dropwizard</url>
    <fullTitle>Liftwizard: Slf4jUncaughtExceptionHandlerBundle, With Dropwizard [Logging]</fullTitle>
    <text>
      <text>To use the exception handler with Dropwizard, add Slf4jUncaughtExceptionHandlerBundle to the list of registered bundles. java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.addBundle(new Slf4jUncaughtExceptionHandlerBundle()); } And add the dependency: xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-logging-uncaught-exception-handler&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/logging/Slf4jUncaughtExceptionHandlerBundle#without-dropwizard</url>
    <fullTitle>Liftwizard: Slf4jUncaughtExceptionHandlerBundle, Without Dropwizard [Logging]</fullTitle>
    <text>
      <text>To use Slf4jUncaughtExceptionHandler without the bundle, create an instance and set it as the default uncaught exception handler. java Thread.setDefaultUncaughtExceptionHandler(new Slf4jUncaughtExceptionHandler()); And add the dependency: xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-logging-uncaught-exception-handler&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/graphql/bundle</url>
    <fullTitle>Liftwizard: Bundle,  [Graphql]</fullTitle>
    <text>
      <text>The LiftwizardGraphQLBundle extends com.smoketurner.dropwizard.graphql.GraphQLBundle .The bundle registers https://github.com/graphql/graphiql the GraphIQL UI at /graphiql and https://github.com/graphql/graphql-playground the GraphQL Playground UI at /graphql-playground , by delegating to AssetsBundle . This overrides the behavior of the smoketurner bundle, which registers just one UI at / (graphiql in older versions, and graphql-playground in newer versions).The bundle also registers two instrumentations for logging and metrics. If you choose not to use the bundle, you can still register the instrumentations separately.To turn it on, add LiftwizardGraphQLBundle to the list of registered bundles. java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { bootstrap.setConfigurationFactoryFactory(new JsonConfigurationFactoryFactory&lt;&gt;()); bootstrap.addBundle(new EnvironmentConfigBundle()); bootstrap.addBundle(new ObjectMapperBundle()); bootstrap.addBundle(new ConfigLoggingBundle()); bootstrap.addBundle(new JerseyHttpLoggingBundle()); bootstrap.addBundle(new LiftwizardGraphQLBundle&lt;&gt;( builder -> { // TODO: Set up GraphQL wiring // builder.scalar(...); // builder.type(...); })); // ... } LiftwizardGraphQLBundle lives in the liftwizard-bundle-graphql module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-bundle-graphql&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/graphql/instrumentation-logging</url>
    <fullTitle>Liftwizard: Instrumentation Logging,  [Graphql]</fullTitle>
    <text>
      <text>LiftwizardGraphQLLoggingInstrumentation is an implementation of Instrumentation from https://www.graphql-java.com/ GraphQL Java that adds helpful context to slf4j's http://www.slf4j.org/manual.html#mdc Mapped Diagnostic Context .For example, say that during the execution of a DataFetcher , we execute a database query and log its sql. It would be helpful to see the query in the context of the DataFetcher that executed it, along with the GraphQL field and its type, and the path we took through the graph on the way to this field.This Instrumentation adds these fields to MDC, prefixed with liftwizard.graphql .To turn it on, either run the entire graphql/bundle.md LiftwizardGraphQLBundle or just add LiftwizardGraphQLLoggingInstrumentation to the list of instrumentations on your GraphQLFactory . java GraphQLFactory factory = ...; var loggingInstrumentation = new LiftwizardGraphQLLoggingInstrumentation(); List&lt;Instrumentation> instrumentations = List.of(loggingInstrumentation); factory.setInstrumentations(instrumentations); Here's an example of what SQL logging might look like with MDC attached when formatted by the "file-logstash" appender. LiftwizardGraphQLLoggingInstrumentation lives in the liftwizard-graphql-instrumentation-logging module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-graphql-instrumentation-logging&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/graphql/instrumentation-metrics</url>
    <fullTitle>Liftwizard: Instrumentation Metrics,  [Graphql]</fullTitle>
    <text>
      <text>LiftwizardGraphQLMetricsInstrumentation is an implementation of Instrumentation from https://www.graphql-java.com/ GraphQL Java that registers https://metrics.dropwizard.io/ performance metrics about data fetching with Dropwizard's MetricsRegistry.To turn it on, either run the entire graphql/bundle.md LiftwizardGraphQLBundle or just add LiftwizardGraphQLMetricsInstrumentation to the list of instrumentations on your GraphQLFactory . java GraphQLFactory factory = ...; Clock clock = Clock.systemUTC(); var metricsInstrumentation = new LiftwizardGraphQLMetricsInstrumentation(this.metricRegistry, clock); var loggingInstrumentation = new LiftwizardGraphQLLoggingInstrumentation(); List&lt;Instrumentation> instrumentations = List.of(metricsInstrumentation, loggingInstrumentation); factory.setInstrumentations(instrumentations); Annotations Next, annotate the DataFetchers that you want to monitor with @Timed , @Metered , and/or @ExceptionMetered . You can annotate either the get() method, or the entire fetcher class. Timers @Timed adds three timers:{DataFetcher's fully-qualified class name}.get.sync liftwizard.graphql.field.{GraphQL Class}.{GraphQL field}.sync liftwizard.graphql.path.{path}.sync All three timers track the number of times each DataFetcher is called, and the amount of time spent in the get() method.Although the timers measure the same thing, they may not have identical values. This would happen if the same DataFetcher is wired to multiple fields, or is reached by multiple paths through the graph.If your DataFetcher returns https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CompletableFuture.html CompleteableFuture , you'll get three additional timers, with names ending in "async" instead of "sync". Rather than track the amount of time spent in get() , these timers will track the amount of time until the CompleteableFutures complete. Meters Timers are meters, so if you want to know the number of times a fetcher is called, annotate them with @Timer.If you annotate your DataFetcher with @Metered , the Intrumentation will add meters that track the number of items returned by the DataFetcher. If the DataFetcher returns a Collection or CompleteableFuture&lt;Collection> , the meter will increment by the size of the Collection. ExceptionMeters @ExceptionMetered adds meters that track the number of times the DataFetcher throws uncaught exceptions, plus the number of CompleteableFutures they return that complete exceptionally. The meters have the same names as the timers, but with the suffix "exceptions":{DataFetcher's fully-qualified class name}.get.exceptions liftwizard.graphql.field.{GraphQL Class}.{GraphQL field}.exceptions liftwizard.graphql.path.{path}.exceptions LiftwizardGraphQLMetricsInstrumentation lives in the liftwizard-graphql-instrumentation-metrics module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-graphql-instrumentation-metrics&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/graphql/data-fetcher-async</url>
    <fullTitle>Liftwizard: Data Fetcher Async,  [Graphql]</fullTitle>
    <text>
      <text>LiftwizardAsyncDataFetcher is an enhanced alternative to AsyncDataFetcher from https://www.graphql-java.com/ GraphQL Java.Both have the ability to wrap a synchronous DataFetcher together with an Executor , and return CompleteableFuture s that execute on the Executor . LiftwizardAsyncDataFetcher also copies slf4j's http://www.slf4j.org/manual.html#mdc Mapped Diagnostic Context to the background tasks, and restores the MDC when each task completes. java builder.dataFetcher( "fieldName", LiftwizardAsyncDataFetcher.async(dataFetcher, executor)); When using Dropwizard, the executor should come from its environment. java ExecutorService executorService = environment .lifecycle() .executorService("my-data-fetcher-%d") .maxThreads(maxThreads) .build(); LiftwizardAsyncDataFetcher lives in the liftwizard-graphql-data-fetcher-async module. xml &lt;dependency> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-graphql-data-fetcher-async&lt;/artifactId> &lt;/dependency></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/reladomo/reladomo-operation-compiler</url>
    <fullTitle>Liftwizard: Reladomo Operation Compiler,  [Reladomo]</fullTitle>
    <text>
      <text>When using https://github.com/goldmansachs/reladomo Reladomo, queries are usually expressed using its code-generated Finder language. java Operation operation = MyTypeFinder.optionalString().eq("value") .and(MyTypeFinder.optionalInteger().eq(4)); MyTypeList mithraList = MyTypeFinder.findMany(operation); In some situations, it can be useful to have a more dynamic way of expressing queries.That's where ReladomoOperationCompiler comes in. It can take a String and compile it into a Reladomo https://www.mvndoc.com/c/com.goldmansachs.reladomo/reladomo/com/gs/fw/finder/Operation.html Operation.In this example, this.stringProperty = "value" &amp; this.integerProperty = 4 is the equivalent query.This can be used for dynamic ad-hoc queries, and combines well with graphql/bundle.md Liftwizard's GraphQL features. java MyTypeFinder finder = MyTypeFinder.getFinderInstance(); var operationText = "this.stringProperty = \"value\" &amp; this.integerProperty = 4"; var compiler = new ReladomoOperationCompiler(); Operation operation = compiler.compile(finder, operationText); MyTypeList mithraList = MyTypeFinder.findMany(operation); Compiling toString() representation The syntax closely matches the toString() representation of Reladomo's Operations, with a little added flexibility. In general, you can call operation.toString() and compile the output to get back an equivalent Operation. java Operation operation = ...; String operationText = operation.toString(); Operation recompiled = compiler.compile(finder, operationText); assertThat(recompiled, is(operation)); Error messages The compiler is designed to give helpful error messages on inputs that parse but don't compile.For example, running the compiler on this.invalidAttributeName = "Value" might throw an error like: text Could not find attribute 'invalidAttributeName' on type 'MyType' in this.invalidAttributeName = "Value". Valid attributes: [idProperty, stringProperty, integerProperty, longProperty, doubleProperty, floatProperty, booleanProperty, instantProperty, localDateProperty, createdById, createdOn, lastUpdatedById, systemFrom, systemTo] Flexible syntax The compiler allows some flexibility in the syntax. toString() Alternatives `&amp;` `&amp;&amp;`, `and` `|` `||`, `or` `&lt;class name>` `this` `lower` `toLowerCase` `abs` `absoluteValue` `=` `==`, `eq` `!=` `not eq`, `notEq` `>` `greaterThan` `>=` `greaterThanEquals` `&lt;` `lessThan` `&lt;=` `lessThanEquals` `not in` `notIn` `not startsWith` `notStartsWith` `not endsWith` `notEndsWith` `not contains` `notContains` `not wildCardEquals` `wildCardNotEquals` `is null` `== null` `is not null` `!= null` `all of &lt;class name}` `all` Complete examples # Attribute types this.booleanProperty = true this.integerProperty = 4 this.longProperty = 5 this.floatProperty = 6.6 this.doubleProperty = 7.7 this.dateProperty = "2010-12-31" this.timeProperty = "2010-12-31T23:59:00.0Z" this.stringProperty = "Value" this.system = "2010-12-31T23:59:00.0Z" # Conjunctions this.booleanProperty = true &amp; this.integerProperty = 4 this.booleanProperty = true &amp;&amp; this.integerProperty = 4 this.booleanProperty = true and this.integerProperty = 4 this.booleanProperty = true | this.integerProperty = 4 this.booleanProperty = true || this.integerProperty = 4 this.booleanProperty = true or this.integerProperty = 4 # Equality operators this.stringProperty = "Value" this.stringProperty != "Value" this.stringProperty is null this.stringProperty == null this.stringProperty is not null this.stringProperty != null this.stringProperty in ["Value", "Value2", null] this.stringProperty not in ["Value", "Value2", null] # String operators this.stringProperty endsWith "Value" this.stringProperty contains "Value" this.stringProperty startsWith "Value" this.stringProperty wildCardEquals "Value?" this.stringProperty not endsWith "Value" this.stringProperty not contains "Value" this.stringProperty not startsWith "Value" this.stringProperty not wildCardEquals "Value?" # Numeric operators this.stringProperty > "Value" this.stringProperty >= "Value" this.stringProperty &lt; "Value" this.stringProperty &lt;= "Value" # Functions / derived attributes toLowerCase(this.stringProperty) = "value" substring(this.stringProperty, 2, 3) = "value" substring(toLowerCase(this.stringProperty), 2, 3) = "value" # Flexible number literals this.floatProperty = 42.0f this.floatProperty = 42.0d this.floatProperty = 42 this.doubleProperty = 42.0f this.doubleProperty = 42.0d this.doubleProperty = 42 this.longProperty = 10_000_000_000 this.integerProperty = 1_000_000_000 # Number / date functions / derived attributes abs(this.integerProperty) = 1 year(this.timeProperty) = 1999 month(this.timeProperty) = 12 dayOfMonth(this.timeProperty) = 31 year(this.dateProperty) = 1999 month(this.dateProperty) = 12 dayOfMonth(this.dateProperty) = 31 # Relationships this.target.value = "value" this.target exists this.target not exists this.target { RelatedType.source.value = "value" } not exists # Edge points this.system equalsEdgePoint</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/database/named-data-source</url>
    <fullTitle>Liftwizard: Named Data Source,  [Database]</fullTitle>
    <text>
      <text>Dropwizard provides an interface called ManagedDataSource . public interface ManagedDataSource extends DataSource, Managed { } It's just a io.dropwizard.lifecycle.Managed and a javax.sql.DataSource . It's a DataSource with start/stop lifecycle methods. ManagedDataSource works well when you have one of them. When you have multiple data sources, it can be difficult to tie them together through configuration. For example, if you use Liquibase for migrations, https://www.dropwizard.io/en/latest/manual/migrations.html#support-for-adding-multiple-migration-bundles you'd need to write code to tie specific migrations to specific data sources; it cannot be done through configuration alone.Liftwizard provides NamedDataSource , which is a ManagedDataSource with a name. liquibase-migrations.md Other Liftwizard bundles expect NamedDataSource s to be configured, and refer to them by name in their own configuration. In the liquibase example, we could tie specific migrations to specific data sources through configuration alone.Different named data sources can refer to different databases, or the same database configured different ways. In the following example, we have one data source for Postgres, and three data sources to connect to h2; over the network, in-memory, and on disk.To use named data sources, start by changing the Configuration class to implement NamedDataSourceFactoryProvider . java public class HelloWorldConfiguration extends Configuration implements NamedDataSourceProvider // , ... other interfaces { // ... } Add a field with type NamedDataSourcesFactory . @JsonUnwrapped private @Valid @NotNull NamedDataSourcesFactory namedDataSourcesFactory = new NamedDataSourcesFactory(); Add the getter/setter required by the interface. @JsonProperty("dataSources") @JsonUnwrapped public NamedDataSourcesFactory getNamedDataSourcesFactory() { return this.namedDataSourcesFactory; } @JsonProperty("dataSources") @JsonUnwrapped public void setNamedDataSourcesFactory(NamedDataSourcesFactory namedDataSourcesFactory) { this.namedDataSourcesFactory = namedDataSourcesFactory; } Now we can use the named data sources in the configuration of other bundles. For example, we use the data source named h2-tcp in the liquibase configuration.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/database/liquibase-migrations</url>
    <fullTitle>Liftwizard: Liquibase Migrations,  [Database]</fullTitle>
    <text>
      <text>Dropwizard ships with a https://www.dropwizard.io/en/latest/manual/migrations.html dropwizard-migrations bundle.The dropwizard-migrations module provides you with a wrapper for https://www.liquibase.org/ Liquibase database refactoring.The built-in bundle provides Dropwizard Commands, for a command line interface to run migrations. It does not provide a way to run migrations on application startup. That's where Liftwizard comes in.To run migrations with Dropwizard, you run a command like java -jar hello-world.jar db migrate helloworld.yml .To run migrations with Liftwizard, you run the usual server command, and Liftwizard will run migrations on startup.There are pros and cons of tying migrations to application startup. The main pros are that you don't have to remember to run migrations, and that they apply to embedded databases in tests. The main con is that migrations can take a long time, and you may not want to block application startup.To turn it on, add LiftwizardLiquibaseMigrationBundle to the list of registered bundles. java @Override public void initialize(Bootstrap&lt;HelloWorldConfiguration> bootstrap) { // ... bootstrap.addBundle(new LiftwizardLiquibaseMigrationBundle()); // ... } Change the Configuration class to implement LiquibaseMigrationFactoryProvider . java public class HelloWorldConfiguration extends Configuration implements LiquibaseMigrationFactoryProvider // , ... other interfaces { // ... } Add a field with type LiquibaseMigrationFactory . private @Valid @NotNull LiquibaseMigrationFactory liquibaseMigrationFactory = new LiquibaseMigrationFactory(); Add the getter/setter required by the interface. @JsonProperty("liquibase") @Override public LiquibaseMigrationFactory getLiquibaseMigrationFactory() { return this.liquibaseMigrationFactory; } @JsonProperty("liquibase") public void setLiquibaseMigrationFactory(LiquibaseMigrationFactory liquibaseMigrationFactory) { this.liquibaseMigrationFactory = liquibaseMigrationFactory; } Configuration The LiftwizardLiquibaseMigrationBundle requires that you're already using database/named-data-source named data sources.Add a liquibase section to your configuration/json5-configuration json or yaml configuration. dataSourceMigrations is an array, to allow multiple migrations to different data sources.Each dataSourceMigration's dataSourceName must match a dataSource's name in the dataSources section.If no migrationFileName is specified, migrations.xml is the default. migrationFileLocation can be classpath or filesystem . classpath is the default. contexts are an array of Liquibase https://docs.liquibase.com/concepts/changelogs/attributes/contexts.html context tags.With this configuration in place, migrations will run on application startup.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/testing/testing</url>
    <fullTitle>Liftwizard: Testing,  [Testing]</fullTitle>
    <text>
      <text>Liftwizard includes utilities for asserting that a string equals the contents of a file."slurping" the file into a string file matching: exact string comparison json matching: json comparison rerecord mode These utilities are implemented as JUnit 4 Rules and JUnit 5 Extensions.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/testing/matching-files</url>
    <fullTitle>Liftwizard: Matching Files,  [Testing]</fullTitle>
    <text>
      <text>Liftwizard includes utilities for asserting that a string equals the contents of a file.If your code has changed enough, it can be more convenient to re-record the test resource files, and review the changes using git diff rather than the test assertion errors. To enable re-record mode, set the environment variable LIFTWIZARD_FILE_MATCH_RULE_RERECORD to true .The setup is different for the JUnit 4 Rule and JUnit 5 Extension. After setup, both have the same API. java this.fileMatchExtension.assertFileContents(expectedStringClassPathLocation, actualString); If the file does not exist, or the contents do not match, an assertion error is added to an https://junit.org/junit4/javadoc/4.12/org/junit/rules/ErrorCollector.html ErrorCollector. If the ErrorCollector contains any errors, the test fails at the end with all expected/actual pairs reported together.If LIFTWIZARD_FILE_MATCH_RULE_RERECORD is set to true , assertFileContents will not emit any AssertionErrors . JUnit 4 java public class ExampleTest { @Rule public final FileMatchRule fileMatchRule = new FileMatchRule(this.getClass()); @Test public void smokeTest() { String resourceClassPathLocation = this.getClass().getSimpleName() + ".txt"; this.fileMatchRule.assertFileContents(resourceClassPathLocation, "test content"); } } JUnit 5 java public class ExampleTest { @RegisterExtension private final FileMatchExtension fileMatchExtension = new FileMatchExtension(this.getClass()); @Test public void smokeTest() { String resourceClassPathLocation = this.getClass().getSimpleName() + ".txt"; this.fileMatchExtension.assertFileContents(resourceClassPathLocation, "test content"); } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/testing/matching-json</url>
    <fullTitle>Liftwizard: Matching Json,  [Testing]</fullTitle>
    <text>
      <text>Liftwizard includes utilities for asserting that a JSON string equals the contents of a file, using JSON equality semantics. Liftwizard delegates to https://github.com/skyscreamer/JSONassert JSONassert for JSON comparison.The API is similar to the ./matching-files file matching API, and re-record mode is enabled with the same environment variable LIFTWIZARD_FILE_MATCH_RULE_RERECORD .The setup is different for the JUnit 4 Rule and JUnit 5 Extension. After setup, both have the same API. java this.jsonMatchExtension.assertFileContents(expectedJsonClassPathLocation, actualJson); If the file does not exist, or the contents do not match, an assertion error is added to an https://junit.org/junit4/javadoc/4.12/org/junit/rules/ErrorCollector.html ErrorCollector. If the ErrorCollector contains any errors, the test fails at the end with all expected/actual pairs reported together.If LIFTWIZARD_FILE_MATCH_RULE_RERECORD is set to true , assertJsonContents will not emit any AssertionErrors . JUnit 4 JsonMatchRule works well with Dropwizard's https://www.dropwizard.io/en/release-2.1.x/manual/testing.html#junit-4 DropwizardAppRule . java public class ExampleTest { @Rule private final DropwizardAppRule&lt;HelloWorldConfiguration> dropwizardAppRule = new DropwizardAppRule&lt;&gt;( ExampleApplication.class, ResourceHelpers.resourceFilePath("config-test.json5")); @Rule public final JsonMatchRule jsonMatchRule = new JsonMatchRule(this.getClass()); @Test public void smokeTest() { Response actualResponse = this.dropwizardAppRule .client() .target("http://localhost:{port}/api/example") .resolveTemplate("port", this.dropwizardAppRule.getLocalPort()) .request() .get(); String actualJsonResponse = actualResponse.readEntity(String.class); String expectedResponseClassPathLocation = this.getClass().getSimpleName() + "." + testName + ".json"; this.jsonMatchRule.assertFileContents(expectedResponseClassPathLocation, actualJsonResponse); } } JUnit 5 JsonMatchExtension works well with Dropwizard's https://www.dropwizard.io/en/stable/manual/testing.html#junit-5 DropwizardAppExtension or Liftwizard's LiftwizardAppExtension . java public class ExampleTest { @RegisterExtension private final LiftwizardAppExtension&lt;?> appExtension = this.getLiftwizardAppExtension(); @RegisterExtension private final JsonMatchExtension jsonMatchExtension = new JsonMatchExtension(this.getClass()); @Nonnull @Override private LiftwizardAppExtension&lt;?> getLiftwizardAppExtension() { return new LiftwizardAppExtension&lt;&gt;( ExampleApplication.class, ResourceHelpers.resourceFilePath("config-test.json5")); } @Test public void smokeTest() { Response actualResponse = this.appExtension .client() .target("http://localhost:{port}/api/example") .resolveTemplate("port", this.appExtension.getLocalPort()) .request() .get(); String actualJsonResponse = actualResponse.readEntity(String.class); String expectedResponseClassPathLocation = this.getClass().getSimpleName() + "." + testName + ".json"; this.jsonMatchExtension.assertFileContents(expectedResponseClassPathLocation, actualJsonResponse); } }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/maven-best-practices</url>
    <fullTitle>Liftwizard: Maven Best Practices,  [Maven]</fullTitle>
    <text>
      <text>There are a number of best practices that can be handled at once by inheriting from a parent pom that takes care of them all.Liftwizard ships with several parent poms that form an inheritance hierarchy. minimal-parent.md liftwizard-minimal-parent is the most minimal parent pom. It is meant to contain uncontroversial best practices that are applicable to all projects. profile-parent.md liftwizard-profile-parent is a parent pom that inherits from liftwizard-minimal-parent and enables several linters and validators in profiles that are off by default. bill-of-materials.md liftwizard-bom is a https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#bill-of-materials-bom-poms Bill of Materials (BOM) that exports all modules within Liftwizard. liftwizard-parent is a parent pom that inherits from liftwizard-profile-parent , selects versions of libraries related to Dropwizard applications, and includes opinionated configurations for plugins. Learning Maven Maven can be confusing due to the extent of the "convention over configuration" approach.For example, to answer "how does maven run compilation before tests" you would need to learn:Plugins which are bound and enabled by default maven-surefire-plugin is the plugin that handles tests maven-compiler-plugin binds to the compile and testCompile phases. maven-surefire-plugin binds to the test phase In the https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#default-lifecycle lifecycle phases compile comes before testCompile which comes before test . None of this information appears in pom.xml , and little of it is logged during the build.To make it easier to understand, liftwizard-minimal-parent includes region markers surrounding each plugin that label the phase that the plugin is bound to. The sections are sorted by phase. &lt;!--region Phase 22: install--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>3.1.2&lt;/version> &lt;/plugin> &lt;!--endregion Phase 22: install--></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#usage</url>
    <fullTitle>Liftwizard: Minimal Parent, Usage [Maven]</fullTitle>
    <text>
      <text>The most minimal parent pom is liftwizard-minimal-parent . If you are able to accept more opinionated defaults, continue to profile-parent liftwizard-profile-parent . The minimal parent is meant to contain uncontroversial best practices that are applicable to all projects.Inherit from liftwizard-minimal-parent in your project's pom.xml: xml &lt;parent> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-minimal-parent&lt;/artifactId> &lt;version>${liftwizard.version}&lt;/version> &lt;/parent></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#what-you-will-get</url>
    <fullTitle>Liftwizard: Minimal Parent, What you will get [Maven]</fullTitle>
    <text>
      <text>The following sections describe the best practices that are enforced by liftwizard-minimal-parent . You will not need to configure these in your project's pom.xml if you inherit from liftwizard-minimal-parent .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#resource-encodings</url>
    <fullTitle>Liftwizard: Minimal Parent, Resource encodings [Maven]</fullTitle>
    <text>
      <text>If you encounter a warning like: [WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent! this is because the project does not https://maven.apache.org/plugins/maven-resources-plugin/examples/encoding.html#specifying-a-character-encoding-scheme specify a character encoding scheme to configure maven-resources-plugin . liftwizard-minimal-parent specifies the character encoding scheme in the properties section of the pom.xml. &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> This will become unnecessary starting with maven 4.x.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#reproducible-builds</url>
    <fullTitle>Liftwizard: Minimal Parent, Reproducible builds [Maven]</fullTitle>
    <text>
      <text>https://reproducible-builds.org/ Reproducible builds are a set of software development practices that create an independently-verifiable path from source to binary code. A build is reproducible if given the same source code, build environment and build instructions, any party can recreate bit-by-bit identical copies of all specified artifacts.You can https://maven.apache.org/guides/mini/guide-reproducible-builds.html#how-do-i-configure-my-maven-build enable Reproducible Builds mode for plugins by specifying locking down the outputTimestamp property. &lt;project.build.outputTimestamp>2024-07-27T17:28:12Z&lt;/project.build.outputTimestamp> You will also need to run mvn artifact:check-buildplan and mvn verify artifact:compare as described in the guide to validate that builds are truly reproducible.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#default-goal</url>
    <fullTitle>Liftwizard: Minimal Parent, Default Goal [Maven]</fullTitle>
    <text>
      <text>You can specify the default goal to run when you run mvn without any arguments. &lt;defaultGoal>verify&lt;/defaultGoal> verify is a better choice than install in the presence of concurrent builds that may write to .m2/repository simultaneously. verify is a better choice than clean verify because developers may build up state like test files and test databases under target/ and may not expect them to be deleted by default. It's easy to run mvn clean when you need it.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#plugins-which-are-bound-and-enabled-by-default</url>
    <fullTitle>Liftwizard: Minimal Parent, Plugins which are bound and enabled by default [Maven]</fullTitle>
    <text>
      <text>Maven builds are configured by binding plugins to https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#default-lifecycle lifecycle phases. Even if you don't declare any plugins in your pom.xml, maven will still bind https://maven.apache.org/ref/3.9.6/maven-core/default-bindings.html#plugin-bindings-for-jar-packaging some plugins to the https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#packaging "main" phases.All versions of maven bind the https://maven.apache.org/ref/3.9.6/maven-core/default-bindings.html#plugin-bindings-for-jar-packaging same plugins, but newer versions of maven bind newer versions of the plugins. If you don't specify the versions of the plugins, different members of the team could be using different versions, leading to different build results on different machines.It's becoming more common to lock down the version of maven itself, but this wasn't always the case. If you haven't specified the versions of these plugins, https://maven.apache.org/enforcer/enforcer-rules/requirePluginVersions.html maven-enforcer-plugin will log an error like: [ERROR] Rule 3: org.apache.maven.enforcer.rules.RequirePluginVersions failed with message: Some plugins are missing valid versions or depend on Maven 3.9.5 defaults (LATEST, RELEASE as plugin version are not allowed) org.apache.maven.plugins:maven-compiler-plugin. The version currently in use is 3.11.0 via default lifecycle bindings org.apache.maven.plugins:maven-surefire-plugin. The version currently in use is 3.1.2 via default lifecycle bindings org.apache.maven.plugins:maven-jar-plugin. The version currently in use is 3.3.0 via default lifecycle bindings org.apache.maven.plugins:maven-clean-plugin. The version currently in use is 3.2.0 via default lifecycle bindings org.apache.maven.plugins:maven-install-plugin. The version currently in use is 3.1.1 via default lifecycle bindings org.apache.maven.plugins:maven-site-plugin. The version currently in use is 3.12.1 via default lifecycle bindings org.apache.maven.plugins:maven-resources-plugin. The version currently in use is 3.3.1 via default lifecycle bindings org.apache.maven.plugins:maven-deploy-plugin. The version currently in use is 3.1.1 via default lifecycle bindings To avoid this, we specify versions of the plugins in the parent pom. &lt;!-- These plugins are bound and enabled by default --> &lt;!-- But the default version of these plugins changes with the version of maven running --> &lt;!--region Phase 0: clean--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.4.0&lt;/version> &lt;/plugin> &lt;!--endregion Phase 0: clean--> &lt;!--region Phase 6: process-resources--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.3.1&lt;/version> &lt;/plugin> &lt;!--endregion Phase 6: process-resources--> &lt;!--region Phase 7: compile--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.13.0&lt;/version> &lt;configuration> &lt;!-- https://maven.apache.org/plugins-archives/maven-compiler-plugin-3.8.1/compile-mojo.html#parameters --> &lt;!-- https://stackoverflow.com/a/44075684/ --> &lt;!-- https://docs.oracle.com/javase/9/tools/javac.htm --> &lt;!-- Generates metadata for reflection on method parameters. Stores formal parameter names of constructors and methods in the generated class file so that the method java.lang.reflect.Executable.getParameters from the Reflection API can retrieve them. --> &lt;parameters>true&lt;/parameters> &lt;/configuration> &lt;/plugin> &lt;!--endregion Phase 7: compile--> &lt;!--region Phase 15: test--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>3.3.1&lt;/version> &lt;!-- In maven 3.9.6 and 4.x, maven is able to auto-detect JUnit and these dependencies are not required --> &lt;!-- In maven 3.9.5, there is an internal exception inside surefire without these declared --> &lt;!-- Even with newer versions of maven, it is advantageous to keep these declarations --> &lt;!-- Without them, maven may only run JUnit 5 tests, in a project with both JUnit 4 and 5 --> &lt;dependencies> &lt;dependency> &lt;groupId>org.junit.jupiter&lt;/groupId> &lt;artifactId>junit-jupiter-engine&lt;/artifactId> &lt;version>5.10.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.junit.platform&lt;/groupId> &lt;artifactId>junit-platform-engine&lt;/artifactId> &lt;version>1.10.3&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.junit.vintage&lt;/groupId> &lt;artifactId>junit-vintage-engine&lt;/artifactId> &lt;version>5.10.3&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;configuration> &lt;!-- The compiler in the server VM now provides correct stack backtraces for all "cold" built-in exceptions. For performance purposes, when such an exception is thrown a few times, the method may be recompiled. After recompilation, the compiler may choose a faster tactic using preallocated exceptions that do not provide a stack trace. To disable completely the use of preallocated exceptions, use this new flag: -XX:-OmitStackTraceInFastThrow. --> &lt;!-- https://stackoverflow.com/a/4659279/ --> &lt;!-- The compiler in the server VM now provides correct stack backtraces for all "cold" built-in exceptions. For performance purposes, when such an exception is thrown a few times, the method may be recompiled. After recompilation, the compiler may choose a faster tactic using preallocated exceptions that do not provide a stack trace. To disable completely the use of preallocated exceptions, use this new flag: -XX:-OmitStackTraceInFastThrow. --> &lt;!-- https://stackoverflow.com/a/4659279/ --> &lt;!-- Add argLine to allow the Jacoco plugin to append without overriding the setting --> &lt;!-- https://stackoverflow.com/a/39818768/ --> &lt;argLine>-XX:-OmitStackTraceInFastThrow @{argLine}&lt;/argLine> &lt;runOrder>random&lt;/runOrder> &lt;trimStackTrace>false&lt;/trimStackTrace> &lt;/configuration> &lt;/plugin> &lt;!--endregion Phase 15: test--> &lt;!--region Phase 17: package--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-jar-plugin&lt;/artifactId> &lt;version>3.4.2&lt;/version> &lt;/plugin> &lt;!--endregion Phase 17: package--&gt; &lt;!--region Phase 22: install--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>3.1.2&lt;/version> &lt;/plugin> &lt;!--endregion Phase 22: install--> &lt;!--region Phase 23: deploy--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>3.1.2&lt;/version> &lt;/plugin> &lt;!--endregion Phase 23: deploy--></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/minimal-parent#no-phase</url>
    <fullTitle>Liftwizard: Minimal Parent, No phase [Maven]</fullTitle>
    <text>
      <text>The are a number of maven plugins with goals that are designed to be run interactively, rather than being bound to a phase in the pom.xml. For example, mvn dependency:tree prints a visual representation of the dependencies of the project, and mvn versions:set updates the versions of dependencies in the pom.xml.Any maven plugin can be run from the command line with mvn groupId:artifactId:version:goal , and configured using command line arguments, without it appearing in the pom.xml. For example, we can run the https://www.mojohaus.org/buildplan-maven-plugin/ buildplan-maven-plugin to list the plugins bound to each phase with this command: shell mvn org.codehaus.mojo:buildplan-maven-plugin:2.2.2:list If we configure the plugin in the pom.xml, we can run it with the syntax mvn phase:goal and add any configuration that would otherwise be specified with -D flags. shell mvn buildplan:list We configure several plugins in the parent pom.xml that are not bound to any phase. &lt;!--mvn versions:display-dependency-updates--> &lt;!--mvn versions:display-plugin-updates--> &lt;!--mvn versions:display-property-updates--> &lt;plugin> &lt;groupId>org.codehaus.mojo&lt;/groupId> &lt;artifactId>versions-maven-plugin&lt;/artifactId> &lt;version>2.17.1&lt;/version> &lt;configuration> &lt;!-- Don't create pom.xml.versionsBackup files --> &lt;generateBackupPoms>false&lt;/generateBackupPoms> &lt;!-- Process all modules in a multi-module build, even aggregator modules without a parent-child relationship --> &lt;!-- https://stackoverflow.com/a/49246337/23572 --> &lt;processAllModules>true&lt;/processAllModules> &lt;/configuration> &lt;/plugin> &lt;!--mvn dependency:tree--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-dependency-plugin&lt;/artifactId> &lt;version>3.7.1&lt;/version> &lt;/plugin> &lt;!--mvn buildplan:list--> &lt;!--mvn buildplan:list-phase--> &lt;!--mvn buildplan:list-plugin--> &lt;plugin> &lt;groupId>org.codehaus.mojo&lt;/groupId> &lt;artifactId>buildplan-maven-plugin&lt;/artifactId> &lt;version>2.2.2&lt;/version> &lt;configuration> &lt;!-- Default value is: deploy --> &lt;tasks> &lt;task>clean&lt;/task> &lt;task>deploy&lt;/task> &lt;/tasks> &lt;!-- print all phases, even if no mapping to an execution is available --> &lt;showAllPhases>true&lt;/showAllPhases> &lt;/configuration> &lt;/plugin> &lt;!--mvnw wrapper:wrapper -Dmaven=4.0.0-alpha-7--> &lt;plugin> &lt;artifactId>maven-wrapper-plugin&lt;/artifactId> &lt;version>3.3.2&lt;/version> &lt;/plugin> &lt;!--mvn clean release:clean release:prepare -DdevelopmentVersion=1.2.3-SNAPSHOT--> &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-release-plugin&lt;/artifactId> &lt;version>3.1.1&lt;/version> &lt;configuration> &lt;!-- Default value is: invoker --> &lt;mavenExecutorId>forked-path&lt;/mavenExecutorId> &lt;!-- Automatically assign submodules the parent version --> &lt;autoVersionSubmodules>true&lt;/autoVersionSubmodules> &lt;!-- Do not `git push` changes to the upstream repository --> &lt;pushChanges>false&lt;/pushChanges> &lt;!-- Format to use when generating the tag name --> &lt;!-- Default value is: @{project.artifactId}-@{project.version} --> &lt;tagNameFormat>@{project.version}&lt;/tagNameFormat> &lt;/configuration> &lt;/plugin></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/maven/profile-parent</url>
    <fullTitle>Liftwizard: Profile Parent,  [Maven]</fullTitle>
    <text>
      <text>The "profile" parent pom inherits from minimal-parent liftwizard-minimal-parent . If you are able to accept more opinionated defaults, continue to bill-of-materials bill-of-materials . The profile parent contains a number of plugins you may want to enable, each wrapped individually in a maven profile. Usage Inherit from liftwizard-profile-parent in your project's pom.xml: xml &lt;parent> &lt;groupId>io.liftwizard&lt;/groupId> &lt;artifactId>liftwizard-profile-parent&lt;/artifactId> &lt;version>${liftwizard.version}&lt;/version> &lt;/parent> What you will get The following sections describe the profiles that are added by liftwizard-profile-parent . You will not need to configure these in your project's pom.xml if you inherit from liftwizard-profile-parent . You can enable the profiles using mvn --activate-profiles &lt;profile1>,&lt;profile2>,... Active by default According to https://maven.apache.org/guides/introduction/introduction-to-profiles.html the docs:Profiles can be active by default using a configuration like the following in a POM. xml &lt;profiles> &lt;profile> &lt;id>profile-name&lt;/id> &lt;activation> &lt;activeByDefault>true&lt;/activeByDefault> &lt;/activation> ... &lt;/profile> &lt;/profiles> This profile will automatically be active for all builds unless another profile in the same POM is activated using one of the previously described methods. All profiles that are active by default are automatically deactivated when a profile in the POM is activated on the command line or through its activation config.This is confusing for new users, who are first confused to find some profiles are enabled by default, and later confused to find out that they are no longer enabled. No profiles in liftwizard-profile-parent are active by default, and we recommend avoiding activeByDefault in your project's pom.xml too. maven-enforcer-plugin &lt;profile> &lt;id>maven-enforcer-plugin&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;artifactId>maven-enforcer-plugin&lt;/artifactId> &lt;configuration> &lt;rules> &lt;dependencyConvergence /> &lt;requirePluginVersions> &lt;banLatest>true&lt;/banLatest> &lt;banRelease>true&lt;/banRelease> &lt;banSnapshots>false&lt;/banSnapshots> &lt;unCheckedPluginList xml:space="preserve"> org.apache.maven.plugins:maven-site-plugin, org.apache.maven.plugins:maven-deploy-plugin &lt;/unCheckedPluginList> &lt;/requirePluginVersions> &lt;bannedDependencies> &lt;excludes combine.children="append"> &lt;exclude>commons-logging-api&lt;/exclude> &lt;exclude>commons-logging&lt;/exclude> &lt;exclude>javax.activation:javax.activation-api&lt;/exclude> &lt;exclude>javax.servlet:javax.servlet-api&lt;/exclude> &lt;exclude>javax.validation:validation-api&lt;/exclude> &lt;exclude>javax.ws.rs:javax.ws.rs-api&lt;/exclude> &lt;exclude>javax.xml.bind:jaxb-api&lt;/exclude> &lt;exclude>javax.xml.ws:jaxws-api&lt;/exclude> &lt;exclude>org.apache.logging.log4j:log4j&lt;/exclude> &lt;exclude>org.slf4j:jcl&lt;/exclude> &lt;exclude>org.slf4j:nop&lt;/exclude> &lt;exclude>org.slf4j:slf4j-jdk14&lt;/exclude> &lt;exclude>org.slf4j:slf4j-simple&lt;/exclude> &lt;/excludes> &lt;/bannedDependencies> &lt;banDuplicatePomDependencyVersions /> &lt;banDuplicateClasses> &lt;findAllDuplicates>true&lt;/findAllDuplicates> &lt;ignoreWhenIdentical>true&lt;/ignoreWhenIdentical> &lt;/banDuplicateClasses> &lt;/rules> &lt;/configuration> &lt;executions> &lt;execution> &lt;id>enforce&lt;/id> &lt;goals> &lt;goal>enforce&lt;/goal> &lt;/goals> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>prettier-check&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.hubspot.maven.plugins&lt;/groupId> &lt;artifactId>prettier-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>check&lt;/goal> &lt;/goals> &lt;phase>validate&lt;/phase> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>prettier-apply&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.hubspot.maven.plugins&lt;/groupId> &lt;artifactId>prettier-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>write&lt;/goal> &lt;/goals> &lt;phase>validate&lt;/phase> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-check&lt;/id> &lt;properties> &lt;spotless.check.skip>false&lt;/spotless.check.skip> &lt;/properties> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>check&lt;/goal> &lt;/goals> &lt;phase>validate&lt;/phase> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-apply&lt;/id> &lt;properties> &lt;spotless.check.skip>false&lt;/spotless.check.skip> &lt;/properties> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;executions> &lt;execution> &lt;goals> &lt;goal>apply&lt;/goal> &lt;/goals> &lt;phase>verify&lt;/phase> &lt;/execution> &lt;/executions> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-formats&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;formats> &lt;format> &lt;toggleOffOn /> &lt;includes> &lt;include>.gitattributes&lt;/include> &lt;include>.gitignore&lt;/include> &lt;/includes> &lt;trimTrailingWhitespace /> &lt;endWithNewline /> &lt;indent> &lt;tabs>true&lt;/tabs> &lt;spacesPerTab>4&lt;/spacesPerTab> &lt;/indent> &lt;/format> &lt;/formats> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-java-sort-imports&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;java> &lt;toggleOffOn> &lt;off>@formatter:off&lt;/off> &lt;on>@formatter:on&lt;/on> &lt;/toggleOffOn> &lt;importOrder> &lt;!-- use an empty string for all the imports not specified explicitly, '|' to join group without blank line, and '\#` prefix for static imports. --> &lt;order>java,javax,,\#com.diffplug,\#java|\#javax,\#&lt;/order> &lt;/importOrder> &lt;removeUnusedImports /> &lt;/java> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-java-unused-imports&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;java> &lt;toggleOffOn> &lt;off>@formatter:off&lt;/off> &lt;on>@formatter:on&lt;/on> &lt;/toggleOffOn> &lt;removeUnusedImports /> &lt;/java> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-prettier-java&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;java> &lt;toggleOffOn> &lt;off>@formatter:off&lt;/off> &lt;on>@formatter:on&lt;/on> &lt;/toggleOffOn> &lt;prettier> &lt;devDependencies> &lt;prettier>3.3.2&lt;/prettier> &lt;prettier-plugin-java>2.6.0&lt;/prettier-plugin-java> &lt;/devDependencies> &lt;config> &lt;tabWidth>4&lt;/tabWidth> &lt;printWidth>120&lt;/printWidth> &lt;parser>java&lt;/parser> &lt;plugins>prettier-plugin-java&lt;/plugins> &lt;/config> &lt;/prettier> &lt;/java> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-google-java-format&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;java> &lt;toggleOffOn> &lt;off>@formatter:off&lt;/off> &lt;on>@formatter:on&lt;/on> &lt;/toggleOffOn> &lt;googleJavaFormat> &lt;version>1.22.0&lt;/version> &lt;style>AOSP&lt;/style> &lt;reflowLongStrings>false&lt;/reflowLongStrings> &lt;/googleJavaFormat> &lt;/java> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-java-cleanthat&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;java> &lt;toggleOffOn> &lt;off>@formatter:off&lt;/off> &lt;on>@formatter:on&lt;/on> &lt;/toggleOffOn> &lt;!-- Cleanthat will refactor code, but it may break style: apply it before formatter --> &lt;cleanthat /> &lt;/java> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-antlr&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;antlr4> &lt;toggleOffOn /> &lt;antlr4Formatter /> &lt;/antlr4> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-sql&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;sql> &lt;toggleOffOn /> &lt;includes> &lt;include>**/*.sql&lt;/include> &lt;/includes> &lt;excludes> &lt;exclude>**/target/**/*.sql&lt;/exclude> &lt;/excludes> &lt;prettier> &lt;devDependencies> &lt;prettier-plugin-sql>0.18.1&lt;/prettier-plugin-sql> &lt;/devDependencies> &lt;config> &lt;plugins>prettier-plugin-sql&lt;/plugins> &lt;/config> &lt;/prettier> &lt;/sql> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-pom&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;pom> &lt;toggleOffOn /> &lt;sortPom> &lt;expandEmptyElements>false&lt;/expandEmptyElements> &lt;spaceBeforeCloseEmptyElement>true&lt;/spaceBeforeCloseEmptyElement> &lt;keepBlankLines>true&lt;/keepBlankLines> &lt;nrOfIndentSpace>4&lt;/nrOfIndentSpace> &lt;!-- Sort order of elements: https://github.com/Ekryd/sortpom/wiki/PredefinedSortOrderProfiles--> &lt;predefinedSortOrder>recommended_2008_06&lt;/predefinedSortOrder> &lt;!-- Custom sort order of elements: https://raw.githubusercontent.com/Ekryd/sortpom/master/sorter/src/main/resources/custom_1.xml --> &lt;sortOrderFile /> &lt;/sortPom> &lt;/pom> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-markdown&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;markdown> &lt;toggleOffOn /> &lt;includes> &lt;include>**/*.md&lt;/include> &lt;/includes> &lt;excludes> &lt;exclude>**/target/**/*.md&lt;/exclude> &lt;/excludes> &lt;flexmark /> &lt;/markdown> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-json&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;json> &lt;toggleOffOn /> &lt;includes> &lt;include&gt;**/*.json&lt;/include> &lt;include>**/*.json5&lt;/include> &lt;/includes> &lt;excludes> &lt;exclude>**/target/**/*.json&lt;/exclude> &lt;exclude>**/target/**/*.json5&lt;/exclude> &lt;exclude>**/archetype-resources/**/*.json&lt;/exclude> &lt;exclude>**/archetype-resources/**/*.json5&lt;/exclude> &lt;/excludes> &lt;prettier> &lt;config> &lt;singleQuote>false&lt;/singleQuote> &lt;/config> &lt;/prettier> &lt;/json> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> &lt;profile> &lt;id>spotless-yaml&lt;/id> &lt;build> &lt;plugins> &lt;plugin> &lt;groupId>com.diffplug.spotless&lt;/groupId> &lt;artifactId>spotless-maven-plugin&lt;/artifactId> &lt;configuration> &lt;yaml> &lt;toggleOffOn /> &lt;includes> &lt;include>**/*.yaml&lt;/include> &lt;include>**/*.yml&lt;/include> &lt;/includes> &lt;excludes> &lt;exclude>**/target/**/*.yaml&lt;/exclude> &lt;exclude>**/target/**/*.yml&lt;/exclude> &lt;/excludes> &lt;prettier> &lt;config> &lt;singleQuote>false&lt;/singleQuote> &lt;/config> &lt;/prettier> &lt;/yaml> &lt;/configuration> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/profile> The Enforcer plugin provides goals to control certain environmental constraints such as Maven version, JDK version and OS family along with many more built-in rules and user created rules.The https://maven.apache.org/enforcer/enforcer-rules/dependencyConvergence.html#dependency-convergence dependencyConvergence rule requires that dependency version numbers converge. If a project has two dependencies, A and B, both depending on the same artifact, C, this rule will fail the build if A depends on a different version of C than the version of C depended on by B.The https://maven.apache.org/enforcer/enforcer-rules/requirePluginVersions.html requirePluginVersions rule enforces that all plugins have a version defined, either in the plugin or pluginManagement section of the pom or a parent pom.The https://maven.apache.org/enforcer/enforcer-rules/bannedDependencies.html bannedDependencies rule is configured to ban all loggers except Log4j 1.x and Logback.The https://maven.apache.org/enforcer/enforcer-rules/banDuplicatePomDependencyVersions.html banDuplicatePomDependencyVersions checks that there are no duplicate dependencies declared in the POM of the project. Duplicate dependencies are dependencies which have the same group id, artifact id, type and classifier. extra-enforcer-rules The https://www.mojohaus.org/extra-enforcer-rules/ extra-enforcer-rules project provides extra rules which are not part of the standard rule set. The liftwizard-minimal-parent configures maven-enforcer-plugin to use the extra-enforcer-rules . &lt;plugin> &lt;groupId>org.apache.maven.plugins&lt;/groupId> &lt;artifactId>maven-enforcer-plugin&lt;/artifactId> &lt;version>3.5.0&lt;/version> &lt;dependencies> &lt;dependency> &lt;groupId>org.codehaus.mojo&lt;/groupId> &lt;artifactId>extra-enforcer-rules&lt;/artifactId> &lt;version>1.8.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/plugin></text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/temporal-data-overview#temporal-features</url>
    <fullTitle>Liftwizard: Temporal Data Overview, Temporal features [Temporal Data]</fullTitle>
    <text>
      <text>Liftwizard has built-in support for working with temporal data. In this section, we'll explore the various features of services that utilize this technology.Note: This section is language and framework agnostic. If you’re interested in the underlying technology, Liftwizard's temporal support is built on reladomo/reladomo-overview.md Reladomo.In an application with temporal data storage, data is stored along with timestamps. Here are some key features of temporal support: temporal-data/non-destructive-updates Non-destructive edits: Updates and deletes won't lose any information. Old data is phased out with a timestamp, and new data is phased in at the same timestamp. temporal-data/as-of-queries As-of queries: Retrieve data as it existed at a specific point in time. temporal-data/versioning Versioning: Numbered versions of data can make working with timestamps easier. As-of queries can be performed by either timestamp or version number. temporal-data/auditing Auditing: Keep track of who made each change, along with the data. With auditing enabled, each version has a user ID in addition to its timestamps. temporal-data/optimistic-locking Optimistic locking: Prevent multiple users from accidentally discarding each other's work with this feature. APIs that perform edits require a version number as input, and will fail if the input version number and current version number don't match. temporal-data/diffs Diff: See the differences between data at two version numbers. temporal-data/maker-checker-workflows Maker/Checker workflows: Make and review changes before exposing them to all users. Most users view the latest approved version of the data, while makers/checkers see the latest version.In the next section, we'll walk through a temporal-data/running-example running example that showcases these features.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/running-example</url>
    <fullTitle>Liftwizard: Running Example,  [Temporal Data]</fullTitle>
    <text>
      <text>Many real-life applications support temporal services. https://stackoverflow.com/ Stack Overflow supports all of the features listed in the temporal-data/temporal-data-overview overview.In this section, we'll use https://www.factorio.school/blueprints Factorio School as a running example. https://www.factorio.school/ Factorio School and https://factorioprints.com/ Factorio Prints are websites that lets users share designs, called https://wiki.factorio.com/Blueprint blueprints, for the video game https://factorio.com/ Factorio. Liftwizard and Factorio School were both created by the https://github.com/motlin/ same author and Factorio School leverages Liftwizard's temporal support.In the next section, we'll create and edit a blueprint, and see how non-destructive edits work.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#post-request-body</url>
    <fullTitle>Liftwizard: Non Destructive Updates, POST Request Body [Temporal Data]</fullTitle>
    <text>
      <text>Blueprints are created in 3 steps, starting with a test clock set at 2001-01-01 .At time 1 ( 2001-01-01 ), we create an Imgur Image entry. At time 2 ( 2001-01-02 ), we upload the blueprint string and receive a sha. At time 3 ( 2001-01-03 ), we upload the blueprint post. In this documentation, we'll focus on the third step.We create a blueprint post by POST ing to /api/blueprint/ . { title: "Blueprint title", blueprintString: { // The blueprintString.sha is a foreign key, pointing to the blueprint data we created at time 2. sha: "cc341849b4086ce7b1893b366b0dc8e99ce4e595", }, imgurImage: { // The imgurImage.imgurId is a foreign key, pointing to the Imgur Image data we created at time 1. imgurId: "Imgur ID 1", }, descriptionMarkdown: "Blueprint description markdown", // Blueprints can be tagged with multiple tags. Here we have a single tag, "belt balancer". tags: [ { // This double nesting is how many-to-many relationships are represented. This object is the BlueprintTag mapping. tag: { // This object is the tag. It's part of reference data that was created earlier. The (category, name) pair is the foreign key. category: "belt", name: "balancer", }, }, ], }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#post-response-body</url>
    <fullTitle>Liftwizard: Non Destructive Updates, POST Response Body [Temporal Data]</fullTitle>
    <text>
      <text>The response includes all the properties we sent, along with server-generated information. { "key": "6ed1f638-a63c-3a54-af67-ba494f27bff2", "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "version": { "number": 1, "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "createdOn": "2001-01-03T23:59:59Z", "createdBy": { "userId": "User ID" }, "lastUpdatedBy": { "userId": "User ID" } }, "title": "Blueprint title", "voteSummary": { "numberOfUpvotes": 0, "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null }, "blueprintString": { "sha": "cc341849b4086ce7b1893b366b0dc8e99ce4e595", "createdOn": "2001-01-02T23:59:59Z", "createdBy": { "userId": "User ID" } }, "imgurImage": { "imgurId": "Imgur ID 1", "imgurType": "image/png", "height": 300, "width": 300, "systemFrom": "2001-01-01T23:59:59Z", "systemTo": null }, "descriptionMarkdown": "Blueprint description markdown", "tags": [ { "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "tag": { "category": "belt", "name": "balancer", "ordinal": 1, "systemFrom": "2000-01-01T00:00:00Z", "systemTo": null } } ] }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#temporal-response</url>
    <fullTitle>Liftwizard: Non Destructive Updates, Temporal Response [Temporal Data]</fullTitle>
    <text>
      <text>Here's the same response, with some temporal features labeled. These will be covered in upcoming sections. { // The key is generated-server side. key: "6ed1f638-a63c-3a54-af67-ba494f27bff2", // The systemFrom is the time we created the blueprint post time 3: 2001-01-03. systemFrom: "2001-01-03T23:59:59Z", // The systemTo is null, or infinity, indicating this data is current. systemTo: null, // The version object is covered in the section on Versioning. version: { number: 1, systemFrom: "2001-01-03T23:59:59Z", systemTo: null, // The createdOn, createdBy, and lastUpdatedBy properties are covered in the section on Auditing. createdOn: "2001-01-03T23:59:59Z", createdBy: { userId: "User ID", }, lastUpdatedBy: { userId: "User ID", }, }, title: "Blueprint title", voteSummary: { numberOfUpvotes: 0, systemFrom: "2001-01-03T23:59:59Z", systemTo: null, }, blueprintString: { // The request only included blueprintString.sha, a foreign key. The response includes the whole object. sha: "cc341849b4086ce7b1893b366b0dc8e99ce4e595", // We created the blueprint data at time 2: 2001-01-02. createdOn: "2001-01-02T23:59:59Z", createdBy: { userId: "User ID", }, }, imgurImage: { // The request only included the imgurImage.id, a foreign key. The response includes the whole object. imgurId: "Imgur ID 1", imgurType: "image/png", height: 300, width: 300, // We created the Imugr image at time 1: 2001-01-01. systemFrom: "2001-01-01T23:59:59Z", systemTo: null, }, descriptionMarkdown: "Blueprint description markdown", tags: [ { // The BlueprintTag mapping was created along with the blueprint post at time 3: 2001-01-03. systemFrom: "2001-01-03T23:59:59Z", systemTo: null, tag: { // The request only included tag.category and tag.name, the composite foreign key. The response includes the whole object. category: "belt", name: "balancer", ordinal: 1, // It was created a year earlier than the Blueprint. systemFrom: "2000-01-01T00:00:00Z", systemTo: null, }, }, ], }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#non-destructive-updates</url>
    <fullTitle>Liftwizard: Non Destructive Updates, Non-destructive updates [Temporal Data]</fullTitle>
    <text>
      <text>Next, we update the blueprint by PATCH ing /api/blueprint/{id}?version=1 .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#response</url>
    <fullTitle>Liftwizard: Non Destructive Updates, Response [Temporal Data]</fullTitle>
    <text>
      <text>The response includes the updated properties we sent, plus our first temporal updates.The edits are reflected at time 4 ( 2001-01-04 ). { "key": "6ed1f638-a63c-3a54-af67-ba494f27bff2", - "systemFrom": "2001-01-03T23:59:59Z", + "systemFrom": "2001-01-04T23:59:59Z", "systemTo": null, "version": { - "number": 1, - "systemFrom": "2001-01-03T23:59:59Z", + "number": 2, + "systemFrom": "2001-01-04T23:59:59Z", "systemTo": null, "createdOn": "2001-01-03T23:59:59Z", "createdBy": { "userId": "User ID" }, "lastUpdatedBy": { "userId": "User ID" } }, - "title": "Blueprint title", + "title": "Edited blueprint title", "voteSummary": { "numberOfUpvotes": 0, "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null }, "blueprintString": { "sha": "cc341849b4086ce7b1893b366b0dc8e99ce4e595", "createdOn": "2001-01-02T23:59:59Z", "createdBy": { "userId": "User ID" } }, "imgurImage": { "imgurId": "Imgur ID 1", "imgurType": "image/png", "height": 300, "width": 300, "systemFrom": "2001-01-01T23:59:59Z", "systemTo": null }, - "descriptionMarkdown": "Blueprint description markdown", + "descriptionMarkdown": "Edited Blueprint description markdown", "tags": [ { "tagCategory": "belt", "tagName": "balancer", "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "tag": { "category": "belt", "name": "balancer", "ordinal": 1, "systemFrom": "2000-01-01T00:00:00Z", "systemTo": null } } ] }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/non-destructive-updates#as-of-query</url>
    <fullTitle>Liftwizard: Non Destructive Updates, As-of query [Temporal Data]</fullTitle>
    <text>
      <text>In the next section, we'll perform our first as-of query to prove to ourselves that no data has been lost.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/as-of-queries#temporal-schema</url>
    <fullTitle>Liftwizard: As Of Queries, Temporal Schema [Temporal Data]</fullTitle>
    <text>
      <text>To confirm that we have not lost any data, we can perform an as-of query. We want to query the state of the blueprint at time 3 ( 2001-01-03 ), before the non-destructive update.We GET from /api/blueprint/{blueprintKey}?asOf={asOf} .We created a blueprint with key 6ed1f638-a63c-3a54-af67-ba494f27bff2 at time 3 ( 2001-01-03 ) and edited it at time 4 ( 2001-01-04 ). We can query as-of any time in the range [2001-01-03, 2001-01-04) . We'll use the beginning of the range: 2001-01-03 .Plugging these values into the template, we GET /api/blueprint/6ed1f638-a63c-3a54-af67-ba494f27bff2?asOf=2001-01-03T23:59:59Z { "key": "6ed1f638-a63c-3a54-af67-ba494f27bff2", "systemFrom": "2001-01-03T23:59:59Z", - "systemTo": null, + "systemTo": "2001-01-04T23:59:59Z", "version": { "number": 1, "systemFrom": "2001-01-03T23:59:59Z", - "systemTo": null, + "systemTo": "2001-01-04T23:59:59Z", "createdOn": "2001-01-03T23:59:59Z", "createdBy": { "userId": "User ID" }, "lastUpdatedBy": { "userId": "User ID" } }, "title": "Blueprint title", "voteSummary": { "numberOfUpvotes": 0, "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null }, "blueprintString": { "sha": "cc341849b4086ce7b1893b366b0dc8e99ce4e595", "createdOn": "2001-01-02T23:59:59Z", "createdBy": { "userId": "User ID" } }, "imgurImage": { "imgurId": "Imgur ID 1", "imgurType": "image/png", "height": 300, "width": 300, "systemFrom": "2001-01-01T23:59:59Z", "systemTo": null }, "descriptionMarkdown": "Blueprint description markdown", "tags": [ { "tagCategory": "belt", "tagName": "balancer", "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "tag": { "category": "belt", "name": "balancer", "ordinal": 1, "systemFrom": "2000-01-01T00:00:00Z", "systemTo": null } } ] } The response we get from /api/blueprint/{blueprintKey}?asOf=2001-01-03T23:59:59Z is nearly identical to the response we would have got from /api/blueprint/{blueprintKey} had we run the query at time 3: 2001-01-03 . This makes sense!There's a small difference in the data. Some of the systemTo values that used to be null are now time 4: 2001-01-04 . This illustrates an important rule of temporal data.All writes into the data store are immutable and append-only, except for the systemTo value.Next we'll focus on the data store. In this example, we're using a relational database, but these concepts apply to any data store.The schema maps closely to the json examples above, so if you're comfortable with the data, feel free to skip ahead to the queries. BLUEPRINT after create systemFrom systemTo key blueprint title descriptionMarkdown imgurImageId blueprintStringSha 2001-01-03 23:59:59.0 9999-12-01 23:59:00.0 6ed1… Blueprint title Blueprint description markdown Imgur ID 1 cc34… BLUEPRINT after update systemFrom systemTo key blueprint title descriptionMarkdown imgurImageId blueprintStringSha `:icon: minus {stroke: 'red'}` 2001-01-03 23:59:59.0 `:icon: plus {stroke: 'green'}` 2001-01-04 23:59:59.0 6ed1… `:icon: minus {stroke: 'red'}` Blueprint title `:icon: minus {stroke: 'red'}` Blueprint description markdown Imgur ID 1 cc34… `:icon: plus {stroke: 'green'}` 2001-01-04 23:59:59.0 9999-12-01 23:59:00.0 6ed1… `:icon: plus {stroke: 'green'}` Edited blueprint title `:icon: plus {stroke: 'green'}` Edited Blueprint description markdown Imgur ID 1 cc34… BLUEPRINT_VERSION after create systemFrom systemTo key createdById lastUpdatedById number createdOn 2001-01-03 23:59:59.0 9999-12-01 23:59:00.0 6ed1… User ID User ID 1 2001-01-03 23:59:59.0 BLUEPRINT_VERSION after update systemFrom systemTo key createdById lastUpdatedById number createdOn `:icon: minus {stroke: 'red'}` 2001-01-03 23:59:59.0 `:icon: plus {stroke: 'green'}` 2001-01-04 23:59:59.0 6ed1… User ID User ID `:icon: minus {stroke: 'red'}` 1 2001-01-03 23:59:59.0 `:icon: plus {stroke: 'green'}` 2001-01-04 23:59:59.0 9999-12-01 23:59:00.0 6ed1… User ID User ID `:icon: plus {stroke: 'green'}` 2 2001-01-03 23:59:59.0 Temporal Schema patterns All tables have systemFrom and systemTo columns. Old data is phased out by setting systemTo to now. New data is phased in by setting systemFrom to now. The new row's systemFrom and the old row's systemTo are set to the same value, forming a contiguous timeline. When several tables are edited within a transaction, the systemFrom and systemTo values are set to the same value across all tables. Unchanged data is copied from the old row to the new row. For very wide columns that don't change frequently, it may be more efficient to split out a separate table. The systemTo value of the new row is set to 9999-12-01 23:59:00.00 to indicate that the row is still active. In json, we had used null to represent the infinity date.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/as-of-queries#temporal-queries-in-sql</url>
    <fullTitle>Liftwizard: As Of Queries, Temporal queries in SQL [Temporal Data]</fullTitle>
    <text>
      <text>As-of queries are implemented in SQL by adding temporal criteria to our WHERE clause. sql select * from BLUEPRINT t0 where t0.key = '6ed1f638-a63c-3a54-af67-ba494f27bff2' and t0.system_from &lt;= '2001-01-03 23:59:59.000' and t0.system_to > '2001-01-03 23:59:59.000' Now we can see why the infinity date is represented as 9999-12-01 23:59:00.00 . If we instead used null we'd need to add additional criteria to our WHERE clauses.Joins that are one hop away from our main table are similar. sql select * from BLUEPRINT_TAG t0 where t0.blueprint_key = '6ed1f638-a63c-3a54-af67-ba494f27bff2' and t0.system_from &lt;= '2001-01-03 23:59:59.000' and t0.system_to > '2001-01-03 23:59:59.000' Joins that are two hops away from our main table are more complicated. We'll see examples of these later. Temporal query patterns We perform asOf queries by adding where system_from &lt;= {asOf} and system_to > {asOf} to our WHERE clause. We add this exact came criteria to every query. We always SELECT all columns from the table. In the examples above we used SELECT * . In production usage, it's common to list the columns explicitly. We never SELECT columns from two tables in the same query. Even in the upcoming examples of joins, we always SELECT from one table at a time. In the next section, we'll learn about adding versions and querying "as of" a version number.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/versioning#query-as-of-version</url>
    <fullTitle>Liftwizard: Versioning, Query as-of version [Temporal Data]</fullTitle>
    <text>
      <text>We've already seen version numbers in some examples. When we edited our Blueprint, the version number increased from 1 to 2.When querying for previous data, version numbers can be more convenient than timestamps. We'll see this in the section on querying by version.With versioning, we bump the version number when we edit any data within the composite. For Blueprints, this means that we bump the version number when we edit the Blueprint itself, when we replace the ImgurImage, when we replace the blueprint string, and when we add or remove tags. We'll take a closer look in the section on Composites.As-of queries by version over rest are performed by adding a version query parameter to the URL.Our template is GET /api/blueprint/{blueprintKey}?version={version} .Plugging in the key from our running example, and the version number 1, we GET /api/blueprint/6ed1f638-a63c-3a54-af67-ba494f27bff2?version=1 This is similar to the as-of query by timestamp from the previous section, and the response is identical so we won't repeat it here.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/versioning#version-queries-in-sql</url>
    <fullTitle>Liftwizard: Versioning, Version queries in SQL [Temporal Data]</fullTitle>
    <text>
      <text>At the SQL layer, queries by version number are implemented by starting with the version table. sql select * from BLUEPRINT_VERSION t0 where t0.key = '6ed1f638-a63c-3a54-af67-ba494f27bff2' and t0.number = 1 This query returns version 1, which existed for the duration [2001-01-03, 2001-01-04) . systemFrom systemTo key createdById lastUpdatedById number createdOn 2001-01-03 23:59:59.0 2001-01-04 23:59:59.0 6ed1… User ID User ID 1 2001-01-03 23:59:59.0 2001-01-04 23:59:59.0 9999-12-01 23:59:00.0 6ed1… User ID User ID 2 2001-01-03 23:59:59.0 At this point we take the system_from value of 2001-01-03 23:59:59.000 and use it in our subsequent queries. The queries on all other tables are identical to the queries in the previous section.For example, to query the BLUEPRINT table: sql select * from BLUEPRINT t0 where t0.key = '6ed1f638-a63c-3a54-af67-ba494f27bff2' and t0.system_from &lt;= '2001-01-03 23:59:59.000' and t0.system_to > '2001-01-03 23:59:59.000'</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/versioning#composites</url>
    <fullTitle>Liftwizard: Versioning, Composites [Temporal Data]</fullTitle>
    <text>
      <text>In the previous example, we edited the Blueprint's title and markdown description, creating version 2.Now we'll replace the Blueprint string, the ImgurImage, and add two more tags. We want to bump the version number just once more, to 3.We update the blueprint by PATCH ing /api/blueprint/{id}?version=2 .</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/versioning#response</url>
    <fullTitle>Liftwizard: Versioning, Response [Temporal Data]</fullTitle>
    <text>
      <text>As desired, we performed the several edits while bumping the version number by only one.In addition, all of the new systemFrom times are identical: 2001-01-05T23:59:59Z .At the SQL level, all the edits were performed in a single transaction. { "key": "6ed1f638-a63c-3a54-af67-ba494f27bff2", - "systemFrom": "2001-01-04T23:59:59Z", + "systemFrom": "2001-01-05T23:59:59Z", "systemTo": null, "version": { - "number": 2, - "systemFrom": "2001-01-04T23:59:59Z", + "number": 3, + "systemFrom": "2001-01-05T23:59:59Z", "systemTo": null, "createdOn": "2001-01-03T23:59:59Z", "createdBy": { "userId": "User ID" }, "lastUpdatedBy": { "userId": "User ID" } }, "title": "Edited blueprint title", "voteSummary": { "numberOfUpvotes": 0, "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null }, "blueprintString": { - "sha": "cc341849b4086ce7b1893b366b0dc8e99ce4e595", - "createdOn": "2001-01-02T23:59:59Z", + "sha": "b11911083a0cf471a5156108389f9899675ccb0c", + "createdOn": "2001-01-03T00:00:00Z", "createdBy": { "userId": "User ID" } }, "imgurImage": { - "imgurId": "Imgur ID 1", - "imgurType": "image/png", - "height": 300, - "width": 300, + "imgurId": "2nd Imgur ID", + "imgurType": "2nd Imgur Type", + "height": 200, + "width": 200, "systemFrom": "2001-01-01T23:59:59Z", "systemTo": null }, "descriptionMarkdown": "Edited Blueprint description markdown", "tags": [ { "tagCategory": "belt", "tagName": "balancer", "systemFrom": "2001-01-03T23:59:59Z", "systemTo": null, "tag": { "category": "belt", "name": "balancer", "ordinal": 1, "systemFrom": "2000-01-01T00:00:00Z", "systemTo": null } + }, + { + "tagCategory": "belt", + "tagName": "prioritizer", + "systemFrom": "2001-01-05T23:59:59Z", + "systemTo": null, + "tag": { + "category": "belt", + "name": "prioritizer", + "ordinal": 2, + "systemFrom": "2000-01-01T00:00:00Z", + "systemTo": null + } + }, + { + "tagCategory": "moderation", + "tagName": "scheduled for deletion", + "systemFrom": "2001-01-05T23:59:59Z", + "systemTo": null, + "tag": { + "category": "moderation", + "name": "scheduled for deletion", + "ordinal": 18, + "systemFrom": "2000-01-01T00:00:00Z", + "systemTo": null + } } ] }</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/versioning#ownership-direction</url>
    <fullTitle>Liftwizard: Versioning, Ownership direction [Temporal Data]</fullTitle>
    <text>
      <text>BlueprintTag sits in the middle of a many-to-many relationship between Blueprint and Tag . In this example, we considered BlueprintTag to be part of the composite making up the Blueprint . Should we also consider it to be part of the Tag as well?This is our choice as application designers. In this case, it makes sense for BlueprintTag to be part of the Blueprint , but not part of Tag .Stack Overflow makes a similar choice. Questions and Tag s are both versioned. Applying new tags to a question creates a new version of the Question , but not the Tag .In the UML diagram above, composite relationships are denoted by black diamonds.Composites are subtle, so let's walk through a few examples.Editing a Blueprint's title or description creates a new version. These are properties directly on the root type. Adding or removing BlueprintTag mappings creates a new version. These objects live within the composite. BlueprintTag mappings don't have any mutable properties. If they did, editing those properties would create a new version. For example, if we persisted their relative ordering with an ordinal property, then reordering the Blueprint's tags would create a new version. When the Blueprint author changes their display name, this does not create a new version. The User object is not part of the composite. We don't allow reassigning Blueprints to another author. If we did, repointing the author would create a new version. This works well with a temporal schema, because Blueprint.createdById would be swapped.</text>
      <score>STANDARD</score>
    </text>
  </entry>
  <entry>
    <url>/docs/temporal-data/auditing</url>
    <fullTitle>Liftwizard: Auditing,  [Temporal Data]</fullTitle>
    <text>
      <text>Auditing means tracking who performed each create and update operation.The version object is a convenient place to store this information. Each version has a createdOn timestamp, and createdBy and lastUpdatedBy fields.The version table includes column createdById and lastUpdatedById that point to a user table. Deletes</text>
      <score>STANDARD</score>
    </text>
  </entry>
</znai>
